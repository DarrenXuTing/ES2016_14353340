### Keil调试器的安装与使用

#### 一、程序的安装
>1、安装MDK474.EXE

> ![](http://i1.piimg.com/567571/a78dea78b95697f6.jpg)
> ![](http://p1.bqimg.com/567571/a0a9be6b6b223964.jpg)

>2、EE319K_InstallSpring2016.exe

> ![](http://p1.bqimg.com/567571/5bd92e5ac9af837a.jpg)

>3、加载FunctionalDebugging文件夹中的.uvproj文件
>![](http://p1.bqimg.com/567571/c0303aff62a3a7b1.jpg)
>4、Startup.s：完成基本的CPU初始化，如果有必要，这里也对外围的设备进行初始化
>![](http://p1.bqimg.com/567571/18348dbec9ab6978.jpg)

>5、main.s：我们的主体程序， 执行完Startup.s后，跳转到Start

>![](http://p1.bqimg.com/567571/6b1048e24ccfe95c.jpg)

#### 二、程序的使用
>1、点击Debug->Start/Stop Debug Session，启动调试器

>![](http://p1.bqimg.com/567571/f76dfcc96cfce7de.jpg)

>2、单步 跟踪运行
>使用菜单Debug->Step 或上图第四个单步运行按钮或使用快捷键 F11 可以单步跟踪执行程序。

>3、全速 运行
>点击工具栏上的“运行”按钮或按F5 键启动全速运行，全速执行程序。

>4、观察／修改寄存器的值

>![](http://p1.bpimg.com/567571/7f83464b311ba59a.jpg)

>用户除了可以观察以外还可自行修改，例如将寄存器R5 的值 0x62 改为 0x85。
方法一：用鼠标点击选中单元R5， 然后再单击其数值位置，出现文字框后输入 0x85 按回车键即可；
方法二：在命令行窗口，输入R5=0x85，按回车键将把 R5 的数值设置为 0x85

>5、观察／修改存储器的数据 
点击菜单“视图View->储存器窗口Memory Windows”，便会打开 储存器Memory 窗口(如窗口已打开，则会关闭)， Memory 窗口可以同时显示 4 个不同的存储器区域，点击窗口下部分的编号可以相互切换显示。
在储存器1（Memory#1） 的地址输入栏内输入“0x20000280”，按回车键后，可以从内部可直接寻址 RAM 的0x20000280 地址处开始显示. 

>![](http://p1.bpimg.com/567571/3ca2ec8c7710956f.jpg)

>点击窗口下部分的储存器2（Memory#2），在 Address 输入栏内输入“0x00000000”，按回车键后，可以从内部可间接寻址 RAM 的 0x0000000 地址处开始显示。

>6、复位 
如果用户想重新开始运行用户程序，可以点击工具栏上的复位按钮，对仿真器的用户程序进行复位。仿真器复位后，程序计数器PC 指针将复位成 0000H，另外，一些内部特殊功能寄存器在复位期间也将重新赋值

>7、设置断点 
将光标移至待设置断点的源程序行，如 “MOV P1,#0B6H”行。点击工具栏上的“断点”图标，可以看到源程序窗口中该行的左边出现了一个红色的断点标记。（如果再点一下这个图标则清除这个断点）同样的方法，您可以设置多个断点。

>![](http://p1.bpimg.com/567571/07860b2c254417ac.jpg)

>8、带断点的全速运行 
按动F5 启动全速运行，全速执行程序，当程序执行到第一个断点时，会暂停下来，这时你可以观察程序中各变量的值及各端口的状态，如下图：第一个断点在mov p1,#06dh 之后，此时在储存器窗口Memory Windows”, 储存器1（Memory#1） 的地址输入栏内输入“0x20000031”，按回车键后，可以从内部可直接寻址地址数据.

>![](http://p1.bpimg.com/567571/9a33f465cd6a7862.jpg)

>9、退出仿真 
>先点击调试工具栏“暂停”按钮，再点击调试工具栏的“复位”复位，再点击 开启/关闭调试模式按钮，则退出仿真状态，就又重新回到编辑模式。（如果不能正确退出，请按一下仿真器上的复位按钮）此时可以对程序修改，然后重新编译，再按开启/关闭调试模式按钮，就又进入仿真模式了。

#### 三、观察Registers和Memory的值的变化
##### Registers
>![](http://p1.bpimg.com/567571/92b8c0ef798e246f.jpg)
##### Memory
>![](http://i1.piimg.com/567571/3c445e70ad589c44.jpg)

#### 四、Cnt变量的最终值和HappyBuf的最终值
>![](http://i1.piimg.com/567571/f0dd37b1faec3153.jpg)

> HappyBuf:0xA8863432  Cnt:0x00000014
main.s程序有两个缓冲区HappyBuf和SadBuf，程序将sad和happy两个8位变量赋为随机数，再将这两个变量转存到数组中。Cnt保存数组偏移量，Cnt被初始化为0，转存时先判断Cnt是否越界，若否，则将变量转存再将Cnt加1.这里一共进行了14次数组的存储，且未越界，故Cnt为14。
